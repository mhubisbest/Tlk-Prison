local DiscordLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/UI-Libs/main/discord%20lib.txt"))()
local win = DiscordLib:Window("TLK")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local EatingEvent = ReplicatedStorage:WaitForChild("Eating")

local player = Players.LocalPlayer
local hrp = player.Character and player.Character:WaitForChild("HumanoidRootPart")

local isFlying = false
local isSpeeding = false
local flyVelocity = nil
local moveSpeed = 100
local lockTarget = nil
local selectedPlayerName = ""
local killAuraWhitelist = {}

local Places = {
    ["Outside"] = CFrame.new(237, 3, -106),
    ["Prison"] = CFrame.new(77, 3, -104),
    ["Basement"] = CFrame.new(468, -6, -89),
    ["Burger"] = CFrame.new(235, 3, -598),
    ["Graveyard"] = CFrame.new(309, 3, -6),
    ["TreeHouse"] = CFrame.new(212, 16, -215),
    ["Subway"] = CFrame.new(345, -25, -164),
    ["Neighborhood"] = CFrame.new(367, 3, -445)
}

local main = win:Server("Main", "http://www.roblox.com/asset/?id=6031075938")
local statistics = win:Server("Player Stats", "http://www.roblox.com/asset/?id=0")

local teleport = main:Channel("Teleport")
local playerChannel = main:Channel("Local Player")
local combat = main:Channel("Combat")
local lockOn = main:Channel("Lockon")
local stats = statistics:Channel("Stats")

local function grabSingleTool(toolName)
    local char = player.Character or player.CharacterAdded:Wait()
    local humanoid = char:WaitForChild("Humanoid")
    local hrp = char:WaitForChild("HumanoidRootPart")
    local toolsFolder = workspace:FindFirstChild("Tools")
    if not toolsFolder then return end

    for _, tool in ipairs(toolsFolder:GetChildren()) do
        if tool.Name == toolName then
            local handle = tool:FindFirstChildWhichIsA("BasePart")
            local clickDetector = tool:FindFirstChildOfClass("ClickDetector") or (handle and handle:FindFirstChildOfClass("ClickDetector"))
            if handle and clickDetector then
                local originalCFrame = hrp.CFrame

                -- Fully sit before starting
                humanoid.Sit = true
                task.wait(0.05)

                -- Stay sitting while approaching
                local startTime = tick()
                while tick() - startTime < 0.4 do
                    humanoid.Sit = true
                    hrp.Velocity = Vector3.zero
                    hrp.CFrame = handle.CFrame * CFrame.new(0, 2, 0)
                    task.wait()
                end

                -- Fire click if close enough
                if (hrp.Position - handle.Position).Magnitude <= (clickDetector.MaxActivationDistance or 32) then
                    fireclickdetector(clickDetector)
                end

                -- Stay sitting for a moment before getting up

                -- Return to original position
                task.wait(0.05)
                hrp.CFrame = originalCFrame

                 task.wait(0.2)
                humanoid.Sit = false
            end
            break
        end
    end
end




for _, toolName in ipairs({"Crowbar", "Axe", "Knife", "Bat", "Pickaxe", "Shovel", "Pipe", "Handsaw", "PoliceBaton"}) do
    combat:Button("Grab " .. toolName, function()
        grabSingleTool(toolName)
    end)
end

for name, cf in pairs(Places) do
    teleport:Button("Teleport to " .. name, function()
        local char = player.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            char.Humanoid.Sit = true
            task.wait(0.2)
            char.HumanoidRootPart.CFrame = cf
        end
    end)
end

local function getPlayerNames()
    local names = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= player then table.insert(names, p.Name) end
    end
    return names
end

combat:Toggle("Kill Aura", false, function(state)
    local Combat = ReplicatedStorage:WaitForChild("Combat")
    local weaponCooldowns = {
        Axe = 2, Bat = 1.3, Pipe = 1.9, Crowbar = 1.7, Fist = 0.7,
        Knife = 0.8, Pickaxe = 2.8, ["Police Baton"] = 0.85, Shovel = 2.2
    }

    local lastUsed = {}
    local highlightInstance = nil
    local currentTarget = nil
    local connection = nil

    local function isHostile(model)
        local hostile = model:FindFirstChild("Hostile")
        return hostile and hostile:IsA("BoolValue") and hostile.Value == true and model:FindFirstChild("Head")
    end

    local function getAllHostiles()
        local list = {}
        for _, model in pairs(workspace:GetChildren()) do
            if model:IsA("Model") and isHostile(model) then
                local modelName = model.Name
                if model ~= player.Character and not killAuraWhitelist[modelName] then
                    table.insert(list, model)
                end
            end
        end
        return list
    end

    local function applyHighlight(target)
        if not target then return end
        if not highlightInstance then
            highlightInstance = Instance.new("Highlight")
            highlightInstance.FillColor = Color3.new(1, 0, 0)
            highlightInstance.OutlineColor = Color3.new(1, 1, 1)
            highlightInstance.FillTransparency = 0.5
            highlightInstance.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            highlightInstance.Parent = game.CoreGui
        end
        highlightInstance.Adornee = target
    end

    local function clearHighlight()
        if highlightInstance then
            highlightInstance:Destroy()
            highlightInstance = nil
        end
    end

    local function getAvailableWeapon()
        local char = player.Character
        if not char then return end
        local available = {}
        for weaponName, cooldown in pairs(weaponCooldowns) do
            local tool = char:FindFirstChild(weaponName) or player.Backpack:FindFirstChild(weaponName)
            if tool and (tick() - (lastUsed[weaponName] or 0)) >= cooldown then
                table.insert(available, {Name = weaponName, Tool = tool, Cooldown = cooldown})
            end
        end
        table.sort(available, function(a, b) return a.Cooldown < b.Cooldown end)
        return available[1]
    end

    local function attack(targetModel)
        local weapon = getAvailableWeapon()
        if not weapon then return end
        local char = player.Character
        if not char then return end
        local tool = weapon.Tool
        if tool.Parent ~= char then tool.Parent = char end
        local head = targetModel:FindFirstChild("Head")
        if head then
            Combat:FireServer(targetModel, head, tool)
            lastUsed[weapon.Name] = tick()
        end
    end

    if state then
        connection = RunService.Heartbeat:Connect(function()
            local char = player.Character
            if not char or not char:FindFirstChild("HumanoidRootPart") then return end

            -- Clear target if it dies or is removed
            if currentTarget and (
                not currentTarget:IsDescendantOf(workspace)
                or not currentTarget:FindFirstChild("Humanoid")
                or currentTarget.Humanoid.Health <= 0
            ) then
                currentTarget = nil
                if highlightInstance then highlightInstance.Adornee = nil end
            end

            -- Acquire new target if none
            if not currentTarget then
                local nearest, dist = nil, math.huge
                for _, model in ipairs(getAllHostiles()) do
                    local hrp = model:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local d = (char.HumanoidRootPart.Position - hrp.Position).Magnitude
                        if d <= 5 and d < dist then
                            nearest, dist = model, d
                        end
                    end
                end
                currentTarget = nearest
                if currentTarget then applyHighlight(currentTarget) end
            end

            -- Attack if valid
            if currentTarget and currentTarget:FindFirstChild("Humanoid") and currentTarget.Humanoid.Health > 0 then
                attack(currentTarget)
            end
        end)
    else
        if connection then connection:Disconnect() end
        clearHighlight()
        currentTarget = nil
    end
end)

playerChannel:Toggle("CFrame Speed", false, function(state) isSpeeding = state end)
playerChannel:Slider("Speed Amount", 10, 300, 100, function(val) moveSpeed = val end)
playerChannel:Toggle("Fly", false, function(state)
    isFlying = state
    if not state and flyVelocity then flyVelocity:Destroy() flyVelocity = nil end
end)

lockOn:Dropdown("Lock on Target", getPlayerNames(), function(name)
    selectedPlayerName = name
    lockTarget = Players:FindFirstChild(name)
end)

lockOn:Button("Refresh Target List", function()
    lockOn:Dropdown("Lock on Target", getPlayerNames(), function(name)
        selectedPlayerName = name
        lockTarget = Players:FindFirstChild(name)
    end)
end)

lockOn:Dropdown("Lock on Target", getPlayerNames(), function(name)
    selectedPlayerName = name
    lockTarget = Players:FindFirstChild(name)
end)

lockOn:Dropdown("Whitelist Player", getPlayerNames(), function(name)
    if not killAuraWhitelist[name] then
        killAuraWhitelist[name] = true
    end
end)

-- Movement Loop
RunService.RenderStepped:Connect(function(dt)
    hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local cam = workspace.CurrentCamera
    local dir = Vector3.zero
    if UserInputService:IsKeyDown(Enum.KeyCode.W) then dir += cam.CFrame.LookVector end
    if UserInputService:IsKeyDown(Enum.KeyCode.S) then dir -= cam.CFrame.LookVector end
    if UserInputService:IsKeyDown(Enum.KeyCode.A) then dir -= cam.CFrame.RightVector end
    if UserInputService:IsKeyDown(Enum.KeyCode.D) then dir += cam.CFrame.RightVector end
    if UserInputService:IsKeyDown(Enum.KeyCode.Space) then dir += Vector3.new(0, 1, 0) end
    if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then dir -= Vector3.new(0, 1, 0) end
    if dir.Magnitude > 0 then dir = dir.Unit end

    -- FIXED CFrame Movement
    if isSpeeding and not isFlying then
        local newPosition = hrp.Position + dir * (moveSpeed * dt)
        local newLook = newPosition + workspace.CurrentCamera.CFrame.LookVector
        hrp.CFrame = CFrame.new(newPosition, newLook)
    end

    -- Fly movement
    if isFlying then
        if not flyVelocity then
            flyVelocity = Instance.new("BodyVelocity")
            flyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            flyVelocity.P = 5000
            flyVelocity.Parent = hrp
        end
        flyVelocity.Velocity = dir * moveSpeed
    end

    -- Lock-on camera
    if lockTarget and lockTarget.Character and lockTarget.Character:FindFirstChild("HumanoidRootPart") then
        local targetHRP = lockTarget.Character.HumanoidRootPart
        cam.CFrame = cam.CFrame:Lerp(CFrame.new(cam.CFrame.Position, targetHRP.Position), 0.15)
    end
end)



local monitoredNames = {
    "BallNChainV", "BlindFolded", "Burning", "CanJump", "CanSprint", "Dashing", "DownState",
    "Flying", "FrontCuffed", "GrabbedByWhom", "Grabbing", "GrabbingWhom", "InAnimation",
    "IsBagged", "IsCuffed", "IsGagged", "IsGrabbed", "IsHogged", "IsLocked", "Kills",
    "LastSplashed", "LockinSeat", "RagDoll", "RagdollTimer", "Reloading", "SJ",
    "Seed", "Struggling", "TryingGrab", "Visualize"
}

local trackedPlayers = {}

local function getStatString(obj)
    if obj:IsA("BoolValue") then
        return tostring(obj.Value and "✅" or "❌")
    elseif obj:IsA("StringValue") or obj:IsA("IntValue") or obj:IsA("NumberValue") then
        return tostring(obj.Value)
    else
        return nil
    end
end

local function trackPlayerStats(playerName, model)
    if trackedPlayers[playerName] then return end
    trackedPlayers[playerName] = true

    local channel = statistics:Channel("Stats - " .. playerName)
    local entries = {}

    local function trackValue(instance)
        local valStr = getStatString(instance)
        if valStr then
            entries[instance.Name] = channel:Label(instance.Name .. ": " .. valStr)
            instance:GetPropertyChangedSignal("Value"):Connect(function()
                entries[instance.Name]:Set(instance.Name .. ": " .. getStatString(instance))
            end)
        end
    end

    for _, name in ipairs(monitoredNames) do
        local obj = model:FindFirstChild(name)
        if obj and obj:IsA("ValueBase") then
            trackValue(obj)
        end
    end

    model.ChildAdded:Connect(function(child)
        if table.find(monitoredNames, child.Name) and child:IsA("ValueBase") and not entries[child.Name] then
            trackValue(child)
        end
    end)
end

local function checkForPlayers()
    for _, p in pairs(Players:GetPlayers()) do
        local model = workspace:FindFirstChild(p.Name)
        if model then
            trackPlayerStats(p.Name, model)
        end
    end

    local localModel = workspace:FindFirstChild("imakeTDSgame")
    if localModel then
        trackPlayerStats("imakeTDSgame", localModel)
    end
end

Players.PlayerAdded:Connect(function(p)
    p.CharacterAdded:Connect(function()
        task.wait(1)
        local model = workspace:FindFirstChild(p.Name)
        if model then
            trackPlayerStats(p.Name, model)
        end
    end)
end)

workspace.ChildAdded:Connect(function(child)
    if Players:FindFirstChild(child.Name) or child.Name == "imakeTDSgame" then
        trackPlayerStats(child.Name, child)
    end
end)

-- Add this **after** all your existing UI setup, near the end of your script:

local espChannel = main:Channel("ESP")

local ESPs = {}
local TEAM_CHECK = true

-- Default Colors
local boxColor = Color3.new(1, 0, 0)
local nameColor = Color3.new(1, 1, 1)
local healthColor = Color3.new(0, 1, 0)

local Camera = workspace.CurrentCamera

local function createESPForPlayer(plr)
    if plr == player then return end
    if ESPs[plr] then return end

    local box = Drawing.new("Square")
    box.Visible = false
    box.Thickness = 2
    box.Color = boxColor
    box.Filled = false

    local nameTag = Drawing.new("Text")
    nameTag.Visible = false
    nameTag.Center = true
    nameTag.Color = nameColor
    nameTag.Size = 16
    nameTag.Outline = true
    nameTag.Font = 2

    local healthBar = Drawing.new("Line")
    healthBar.Visible = false
    healthBar.Color = healthColor
    healthBar.Thickness = 4

    ESPs[plr] = {Box = box, Name = nameTag, HealthBar = healthBar}
end

local function removeESPForPlayer(plr)
    if ESPs[plr] then
        for _, obj in pairs(ESPs[plr]) do
            obj.Visible = false
            obj:Remove()
        end
        ESPs[plr] = nil
    end
end

local function updateESP()
    for plr, esp in pairs(ESPs) do
        local char = plr.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        local hum = char and char:FindFirstChildOfClass("Humanoid")

        if char and hrp and hum and hum.Health > 0 then
            local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
            if onScreen then
                local sizeFactor = 200 / (pos.Z + 0.1) -- Scale box size with distance
                local boxSize = Vector2.new(40, 80) * sizeFactor

                esp.Box.Size = boxSize
                esp.Box.Position = Vector2.new(pos.X - boxSize.X / 2, pos.Y - boxSize.Y / 2)
                esp.Box.Color = boxColor
                esp.Box.Visible = true

                esp.Name.Text = plr.Name
                esp.Name.Position = Vector2.new(pos.X, pos.Y - boxSize.Y / 2 - 20)
                esp.Name.Color = nameColor
                esp.Name.Visible = true

                local healthPercent = math.clamp(hum.Health / hum.MaxHealth, 0, 1)
                local hbStart = Vector2.new(esp.Box.Position.X - 8, esp.Box.Position.Y + esp.Box.Size.Y)
                local hbEnd = Vector2.new(hbStart.X, hbStart.Y - esp.Box.Size.Y * healthPercent)
                esp.HealthBar.From = hbStart
                esp.HealthBar.To = hbEnd
                esp.HealthBar.Color = healthColor
                esp.HealthBar.Visible = true

                if TEAM_CHECK and plr.Team == player.Team then
                    esp.Box.Visible = false
                    esp.Name.Visible = false
                    esp.HealthBar.Visible = false
                end
            else
                esp.Box.Visible = false
                esp.Name.Visible = false
                esp.HealthBar.Visible = false
            end
        else
            esp.Box.Visible = false
            esp.Name.Visible = false
            esp.HealthBar.Visible = false
        end
    end
end

local espEnabled = false
local espConnection = nil

local function toggleESP(state)
    espEnabled = state
    if espEnabled then
        for _, plr in pairs(Players:GetPlayers()) do
            createESPForPlayer(plr)
        end
        espConnection = RunService.RenderStepped:Connect(updateESP)
    else
        if espConnection then espConnection:Disconnect() espConnection = nil end
        for plr, esp in pairs(ESPs) do
            for _, obj in pairs(esp) do
                obj.Visible = false
                obj:Remove()
            end
        end
        ESPs = {}
    end
end

-- ESP UI Elements
espChannel:Toggle("Enable ESP", false, function(state)
    toggleESP(state)
end)

espChannel:Toggle("Team Check", TEAM_CHECK, function(state)
    TEAM_CHECK = state
end)

-- Player Added / Removing listeners
Players.PlayerAdded:Connect(function(plr)
    if espEnabled then createESPForPlayer(plr) end
end)

Players.PlayerRemoving:Connect(removeESPForPlayer)